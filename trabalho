#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Defini√ß√£o do tamanho m√°ximo para o nome da sala
#define TAMANHO_NOME 50

// --- Estrutura de Dados ---

/**
 * @brief Estrutura que representa um c√¥modo (n√≥) da mans√£o.
 * Cont√©m o nome da sala e ponteiros para os caminhos poss√≠veis.
 */
typedef struct Sala {
    char nome[TAMANHO_NOME];
    struct Sala *esquerda; // Ponteiro para o caminho da esquerda
    struct Sala *direita;  // Ponteiro para o caminho da direita
} Sala;

// --- Fun√ß√µes de Modulariza√ß√£o ---

/**
 * @brief Cria e aloca dinamicamente um novo c√¥modo (n√≥) na √°rvore.
 * @param nome_sala O nome a ser atribu√≠do ao novo c√¥modo.
 * @return O ponteiro para a nova Sala criada.
 */
Sala* criarSala(const char *nome_sala) {
    // 1. Aloca mem√≥ria para a nova sala
    Sala *nova_sala = (Sala*)malloc(sizeof(Sala));
    
    // 2. Verifica se a aloca√ß√£o foi bem-sucedida
    if (nova_sala == NULL) {
        perror("Erro na aloca√ß√£o de mem√≥ria para nova sala");
        exit(EXIT_FAILURE);
    }
    
    // 3. Inicializa os campos
    strncpy(nova_sala->nome, nome_sala, TAMANHO_NOME - 1);
    nova_sala->nome[TAMANHO_NOME - 1] = '\0'; // Garantir termina√ß√£o da string
    nova_sala->esquerda = NULL;
    nova_sala->direita = NULL;
    
    return nova_sala;
}

/**
 * @brief Permite a navega√ß√£o interativa do jogador pela √°rvore bin√°ria.
 * A explora√ß√£o continua at√© o n√≥-folha ou at√© o jogador desistir.
 * @param atual O ponteiro para a sala atual onde o jogador se encontra.
 */
void explorarSalas(Sala *atual) {
    char escolha;
    
    // O loop continua enquanto houver uma sala para explorar
    while (atual != NULL) {
        printf("\nVoc√™ est√° em: **%s**\n", atual->nome);

        // Verifica se √© um n√≥-folha (sem caminhos)
        if (atual->esquerda == NULL && atual->direita == NULL) {
            printf("\nüéâ Fim da explora√ß√£o! Este c√¥modo n√£o tem mais sa√≠das. üéâ\n");
            return; // Encerra a explora√ß√£o
        }

        // --- Op√ß√µes de Navega√ß√£o ---
        printf("Para onde deseja ir?\n");
        
        if (atual->esquerda != NULL) {
            printf("  [e] -> Esquerda (%s)\n", atual->esquerda->nome);
        }
        if (atual->direita != NULL) {
            printf("  [d] -> Direita (%s)\n", atual->direita->nome);
        }
        printf("  [s] -> Sair da mans√£o\n");
        printf("Escolha (e/d/s): ");

        // Leitura da escolha do usu√°rio
        if (scanf(" %c", &escolha) != 1) {
            // Limpa o buffer de entrada em caso de falha de leitura
            while(getchar() != '\n'); 
            escolha = ' '; // Define uma escolha inv√°lida
        }
        
        // --- Processamento da Escolha ---
        if (escolha == 'e' || escolha == 'E') {
            if (atual->esquerda != NULL) {
                atual = atual->esquerda; // Move para a esquerda
            } else {
                printf("Caminho 'esquerda' n√£o existe. Tente outra op√ß√£o.\n");
            }
        } else if (escolha == 'd' || escolha == 'D') {
            if (atual->direita != NULL) {
                atual = atual->direita; // Move para a direita
            } else {
                printf("Caminho 'direita' n√£o existe. Tente outra op√ß√£o.\n");
            }
        } else if (escolha == 's' || escolha == 'S') {
            printf("\nüö™ Voc√™ decidiu sair da mans√£o. At√© logo!\n");
            return;
        } else {
            printf("Op√ß√£o inv√°lida. Digite 'e', 'd' ou 's'.\n");
        }
    }
}

/**
 * @brief Libera a mem√≥ria alocada para toda a √°rvore.
 * @param raiz O ponteiro para a raiz da sub√°rvore a ser liberada.
 */
void liberarMemoria(Sala *raiz) {
    if (raiz == NULL) {
        return;
    }
    // Libera√ß√£o em P√≥s-ordem (Post-order traversal)
    liberarMemoria(raiz->esquerda);
    liberarMemoria(raiz->direita);
    free(raiz);
}

// --- Fun√ß√£o Principal ---

int main() {
    printf("======================================\n");
    printf("üö™ Bem-vindo √† Mans√£o do C√≥digo Secreto! üóùÔ∏è\n");
    printf("======================================\n");
    printf("Regra: Escolha 'e' (esquerda) ou 'd' (direita) para avan√ßar.\n");

    // --- Montagem do Mapa da Mans√£o (Cria√ß√£o Manual da √Årvore Bin√°ria) ---
    // A estrutura √© criada de forma manual conforme o requisito.
    
    // N√≠vel 0: Raiz
    Sala *hall = criarSala("Hall de Entrada");

    // N√≠vel 1
    Sala *sala_estar = criarSala("Sala de Estar");
    Sala *cozinha = criarSala("Cozinha");
    hall->esquerda = sala_estar;
    hall->direita = cozinha;

    // N√≠vel 2 (Filhos da Sala de Estar)
    Sala *biblioteca = criarSala("Biblioteca");
    Sala *jardim = criarSala("Jardim"); // N√≥-folha
    sala_estar->esquerda = biblioteca;
    sala_estar->direita = jardim;

    // N√≠vel 2 (Filhos da Cozinha)
    Sala *dispensa = criarSala("Dispensa"); // N√≥-folha
    Sala *escritorio = criarSala("Escrit√≥rio");
    cozinha->esquerda = dispensa;
    cozinha->direita = escritorio;

    // N√≠vel 3 (Filhos da Biblioteca)
    Sala *quarto_principal = criarSala("Quarto Principal"); // N√≥-folha
    biblioteca->esquerda = quarto_principal;
    // Biblioteca->direita √© NULL

    // N√≠vel 3 (Filhos do Escrit√≥rio)
    Sala *porao = criarSala("Por√£o"); // N√≥-folha
    escritorio->direita = porao;
    // Escritorio->esquerda √© NULL

    /*
     * Estrutura da √Årvore (Mapa da Mans√£o):
     * * (Hall de Entrada)
     * /                 \
     * (Sala de Estar)           (Cozinha)
     * /      \               /      \
     * (Biblioteca) (Jardim)  (Dispensa) (Escrit√≥rio)
     * /         (Folha)    (Folha)        \
     * (Quarto Principal)                    (Por√£o)
     * (Folha)                          (Folha)
     */
     
    // --- In√≠cio da Explora√ß√£o Interativa ---
    explorarSalas(hall);
    
    // --- Limpeza de Mem√≥ria ---
    liberarMemoria(hall);
    printf("\n\nMem√≥ria alocada liberada com sucesso.\n");

    return 0;
}
